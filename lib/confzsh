#!/usr/bin/env bash

# ----------------------------------------
# ZSH Plugin Manager + Oh-My-Zsh Installer
# ----------------------------------------

ZSHRC="$HOME/.zshrc"
ZSH="$HOME/.oh-my-zsh"
ZSH_CUSTOM="${ZSH_CUSTOM:-$ZSH/custom}"

# Function 1: Install Oh-My-Zsh manually
install_oh_my_zsh() {
  if [ -d "$ZSH" ]; then
    echo "‚ö†Ô∏è  Oh-My-Zsh already installed at $ZSH"
    return
  fi

  echo "‚¨áÔ∏è  Installing Oh-My-Zsh..."
  git clone https://github.com/ohmyzsh/ohmyzsh.git "$ZSH"

  # create default .zshrc if not exists
  if [ ! -f "$ZSHRC" ]; then
    cp "$ZSH/templates/zshrc.zsh-template" "$ZSHRC"
    sed -i 's/plugins=(git)/plugins=()/' $ZSHRC
    echo "‚úÖ Default .zshrc created"
  fi

  echo "‚úÖ Oh-My-Zsh installed at $ZSH"
  echo "üëâ Restart your shell or run: source ~/.zshrc"
}

# Function 1: Safe add to .zshrc
add_zsh_plugin() {
  local plugin=" $1"
  # Agar plugins= line hi nahi hai ‚Üí naya create karo
  if ! grep -q "^plugins=" "$ZSHRC"; then
    echo "plugins=($plugin)" >>"$ZSHRC"
    echo "‚úÖ Plugin '$plugin' added (new plugins line created)"
    return
  fi

  # Current plugins extract karo
  local current
  current=$(sed -n 's/^plugins=(\(.*\))/\1/p' "$ZSHRC")

  # Duplicate check: remove leading/trailing spaces from each plugin
  if echo "$current" | tr ' ' '\n' | sed 's/^ *//;s/ *$//' | grep -qx "${plugin## }"; then
    echo "‚≠ê Plugin '${plugin## }' already enabled in .zshrc (skipped)"
    return
  fi

  # Naya list append karo aur overwrite karo
  local updated="plugins=($current$plugin)"
  sed -i "s/^plugins=(.*)/$updated/" "$ZSHRC"

  echo "‚úÖ Plugin '${plugin## }' added to .zshrc"
}

add_gh_plugin() {
  local repo="$1"
  local plugin_name
  plugin_name=$(basename "$repo")

  if [ ! -d "$ZSH_CUSTOM/plugins/$plugin_name" ]; then
    git clone "https://github.com/$repo.git" "$ZSH_CUSTOM/plugins/$plugin_name"
    echo "‚úÖ GitHub plugin '$repo' cloned"
  else
    echo "üö®  Plugin '$repo' already exists locally"
  fi

  add_zsh_plugin "$plugin_name" # ‚úÖ only basename
}

fzf_add_plugin() {
  local choices=(
    "z"
    "git"
    "zsh-users/zsh-autosuggestions"
    "zsh-users/zsh-syntax-highlighting"
    "zsh-users/zsh-completions"
  )

  local green_star=$'\033[32mÔÄÖ\033[0m'

  # Read current plugins from .zshrc (multi-line safe)
  local current_plugins
  current_plugins=$(
    sed -n '/^plugins=(/,/)/p' "$ZSHRC" |
      tr -d '()' | tr -s '[:space:]' '\n'
  )

  local options=()
  local i=1
  for c in "${choices[@]}"; do
    local name
    if [[ "$c" == */* ]]; then
      name=$(basename "$c") # e.g. "joshskidmore/zsh-fzf-history-search" ‚Üí "zsh-fzf-history-search"
    else
      name="$c"
    fi

    local display="$c"

    # Green star logic
    if echo "$current_plugins" | grep -qx "$name"; then
      # Plugin enabled in .zshrc
      if [ -d "$ZSH_CUSTOM/plugins/$name" ] || [ -d "$ZSH/plugins/$name" ]; then
        display="$c $green_star"
      fi
    fi

    options+=("$i. $display")
    ((i++))
  done

  # Run fzf with multi-select
  local selection
  selection=$(printf "%s\n" "${options[@]}" |
    fzf -m --prompt="Select plugin(s) ‚û§ " --exit-0 \
      --height=40% --border --ansi --no-info --reverse --no-scrollbar)

  if [[ -z "$selection" ]]; then
    echo "‚ùå No plugins selected"
    return
  fi

  # Process each selected line
  while IFS= read -r choice; do
    local selected="${choice#*. }" # strip numbering
    selected="${selected%% *}"     # strip possible star

    if [[ "$selected" == */* ]]; then
      add_gh_plugin "$selected"
    else
      add_zsh_plugin "$selected"
    fi
  done <<<"$selection"
}

# remove zsh plugins
remove_zsh_plugin() {
  # Extract current plugins and trim spaces
  local current
  current=$(sed -n 's/^plugins=(\(.*\))/\1/p' "$ZSHRC" | xargs)

  if [[ -z "$current" ]]; then
    echo "üö®   No plugins found in $ZSHRC"
    return
  fi

  # Convert to array, ignoring empty entries
  local plugins_array=()
  for p in $current; do
    [[ -n "$p" ]] && plugins_array+=("$p")
  done

  # Prepare numbered list safely (no trailing newline)
  local numbered_list=""
  for i in "${!plugins_array[@]}"; do
    numbered_list+="$((i + 1)). ${plugins_array[i]}"
    [[ $i -lt $((${#plugins_array[@]} - 1)) ]] && numbered_list+=$'\n'
  done

  # Multi-select with fzf
  local selection
  selection=$(echo "$numbered_list" |
    fzf -m --prompt="Select plugin(s) ‚û§ " --exit-0 \
      --height=40% --border --ansi --no-info --reverse --no-scrollbar \
    )

  # If user cancels fzf
  [[ -z "$selection" ]] && {
    echo "‚ùå No plugin selected"
    return
  }

  # Extract plugin names (strip numbers and dot)
  local selected_plugins=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && selected_plugins+=("$(echo "$line" | sed 's/^[0-9]\+\. //')")
  done <<<"$selection"

  # Build updated plugin list by excluding selected plugins
  local updated=""
  for p in "${plugins_array[@]}"; do
    skip=false
    for sp in "${selected_plugins[@]}"; do
      [[ "$p" == "$sp" ]] && skip=true
    done
    [[ "$skip" == false ]] && updated="$updated $p"
  done

  # Overwrite plugins line in .zshrc
  sed -i "s/^plugins=(.*)/plugins=($updated)/" "$ZSHRC"

  echo "‚úÖ Removed plugin(s): ${selected_plugins[*]}"
}

# Function 5: Change ZSH theme
change_zsh_theme() {
  local theme="$1"

  if [ -z "$theme" ]; then
    echo "‚ùå Usage: change_zsh_theme <theme-name>"
    return
  fi

  if grep -q '^ZSH_THEME=' "$ZSHRC"; then
    sed -i "s/^ZSH_THEME=.*/ZSH_THEME=\"$theme\"/" "$ZSHRC"
  else
    echo "ZSH_THEME=\"$theme\"" >>"$ZSHRC"
  fi

  echo "‚úÖ Theme changed to '$theme' in .zshrc"
}

create_custom_theme() {
  local theme_name="${1:-theader}" # default name = theader
  local theme_dir="$ZSH_CUSTOM/themes"
  local theme_file="$theme_dir/$theme_name.zsh-theme"

  mkdir -p "$theme_dir"

  if [ -f "$theme_file" ]; then
    echo "üö®    Theme '$theme_name' already exists at $theme_file"
    return
  fi

  # Use quoted heredoc to prevent expansion
  cat >"$theme_file" <<'EOF'
# -----------------------------------------------------
# Custom Oh-My-Zsh Theme Template
# Name: theader
# -----------------------------------------------------

# # custom zsh highlight config output
if [[ "$plugins" == *"zsh-syntax-highlighting"* ]]; then
  ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=39'
  ZSH_HIGHLIGHT_STYLES[comment]='fg=226,bold'
  zle_highlight=(default:bold,fg=white)
fi

# custom function for PROMPT and RPROMPT zsh shell
CONFIG="$HOME/.config/theader/theader.cfg"

# Default value = current username
TNAME=$(whoami)

# If config exists and has TNAME set, load it
if [ -f "$CONFIG" ]; then
  # Read value of TNAME= from config file (simple KEY=VALUE format)
  prompt_name=$(grep '^TNAME=' "$CONFIG" | cut -d'=' -f2-)

  if [ -n "$prompt_name" ]; then
    TNAME="$prompt_name"
  fi
fi

setopt prompt_subst

ZSH_THEME_GIT_PROMPT_PREFIX="%F{8}ÓÇ∂%K{8}%F{0}Ôêò %K{2} %F{white}%B"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{%k%}%F{2}ÓÇ¥%f"
ZSH_THEME_GIT_PROMPT_DIRTY="%F{1}*%f"
ZSH_THEME_GIT_PROMPT_CLEAN=""
function get_date() { echo "$(date +'%d/%b/%y')" }
function get_time() { echo "$(date +'%l:%M')" }
function get_time_pm() { echo "$(date +'%p')" }
function get_cal_icon() { echo "ÔÅ≥"}
get_day () { echo "$(date +'%a')" }
_dd () { echo "%F{2}ÓÇ∂%K{2}%F{black}%b$(get_cal_icon) %F{white}%B$(get_date)%b %k%K{8} %F{0}$(get_day)%{%k%}%F{8}ÓÇ¥%f" }
_time (){ echo "%F{0}ÓÇ∂%K{0}%F{white}$(get_time) %K{8} %F{4}$(get_time_pm)%{%k%}%F{8}ÓÇ¥%f" }
background_jobs="%(1j.%F{2}Óòï%f.)"
non_zero_return_value="%(0?..%F{1}ÔÄç%f)"
## prompt strart from here
RPROMPT=' $background_jobs $non_zero_return_value $(git_prompt_info) $(_dd)'
PROMPT=$'
%{\e[0;31m%}‚îå‚îÄ[%{\e[1;34m%}%B%{${TNAME}%}%{\e[1;33m%}@%{\e[1;36m%}termux%b%{\e[0;31m%}]‚îÄ[%{\e[0;32m%}%(4~|/%2~|%~)%{\e[0;31m%}]%b
%{\e[0;31m%}‚îî‚îÄ‚îÄ‚ïº %{\e[1;31m%}%BÓäÖ%{\e[1;34m%}ÓäÖ%{\e[1;90m%}ÓäÖ%{\e[0m%}%b '
EOF

  echo "‚úÖ Custom theme '$theme_name' created at $theme_file"
  echo "üëâ To use it, run: change_zsh_theme $theme_name"
}
